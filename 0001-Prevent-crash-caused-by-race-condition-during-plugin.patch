From 554e57558bf00c6764686917acd4892217d78960 Mon Sep 17 00:00:00 2001
From: Petr Spacek <pspacek@redhat.com>
Date: Wed, 20 Mar 2013 12:58:09 +0100
Subject: [PATCH] Prevent crash caused by race condition during plugin
 initialization.

Processing of global configuration was postponed. Now the persistent
search watcher thread doesn't change configuration directly.

The problem was that isc_task_beginexclusive()
was called before task associated with psearch watcher thread
was fully initialized.

Now the watcher enqueues a new configuration change event
and this event is processed later by another thread.

https://fedorahosted.org/bind-dyndb-ldap/ticket/110

Signed-off-by: Petr Spacek <pspacek@redhat.com>
---
 src/ldap_helper.c | 22 +++++++++++++++-------
 1 file changed, 15 insertions(+), 7 deletions(-)

diff --git a/src/ldap_helper.c b/src/ldap_helper.c
index 0c9e879..b4162bb 100644
--- a/src/ldap_helper.c
+++ b/src/ldap_helper.c
@@ -1458,18 +1458,26 @@ refresh_zones_from_ldap(ldap_instance_t *ldap_inst, isc_boolean_t delete_only)
 	 * before processing them. It prevents deadlock in situations where
 	 * ldap_parse_zoneentry() requests another connection. */
 	CHECK(ldap_pool_getconnection(ldap_inst->pool, &ldap_conn));
-	CHECK(ldap_query(ldap_inst, ldap_conn, &ldap_config_qresult, str_buf(ldap_inst->base),
-			 LDAP_SCOPE_SUBTREE, config_attrs, 0,
-			 "(objectClass=idnsConfigObject)"));
 	CHECK(ldap_query(ldap_inst, ldap_conn, &ldap_zones_qresult, str_buf(ldap_inst->base),
 			 LDAP_SCOPE_SUBTREE, zone_attrs, 0,
 			 "(&(objectClass=idnsZone)(idnsZoneActive=TRUE))"));
+
+	/* Do not touch configuration from psearch watcher thread, otherwise
+	 * BIND will crash. The problem is that isc_task_beginexclusive()
+	 * is called before task associated with psearch watcher thread
+	 * is fully initialized. */
+	if (!delete_only)
+		CHECK(ldap_query(ldap_inst, ldap_conn, &ldap_config_qresult,
+				str_buf(ldap_inst->base), LDAP_SCOPE_SUBTREE,
+				config_attrs, 0, "(objectClass=idnsConfigObject)"));
+
 	ldap_pool_putconnection(ldap_inst->pool, &ldap_conn);
 
-	for (entry = HEAD(ldap_config_qresult->ldap_entries);
-	     entry != NULL;
-	     entry = NEXT(entry, link)) {
-		CHECK(ldap_parse_configentry(entry, ldap_inst));
+	if (!delete_only) {
+		for (entry = HEAD(ldap_config_qresult->ldap_entries);
+		     entry != NULL;
+		     entry = NEXT(entry, link))
+			CHECK(ldap_parse_configentry(entry, ldap_inst));
 	}
 
 	/*
-- 
1.8.1.4

